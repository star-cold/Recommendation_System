"""
摘自 https://blog.csdn.net/guicaizhou/article/details/80584769
协同过滤
核心是用户交互数据建模
基于协同过滤的推荐可以分为三个子类：
1 基于用户的推荐（User-based Recommendation），
2 基于物品的推荐（Item-based Recommendation）和
3 基于模型的推荐（Model-based Recommendation）。

1.基于用户的协同过滤推荐
它的基本假设是，喜欢类似物品的用户可能有相同或者相似的口味和偏好。
根据所有用户对物品或者信息的偏好，发现与当前用户口味和偏好相似的“邻居”用户群，在一般的应用中是采用计算“K- 邻居”的算法；
然后，基于这 K 个邻居的历史偏好信息，为当前用户进行推荐。

a)分析各个用户对item的评价（通过浏览记录、购买记录等)
b)依据用户对item的评价计算得出所有用户之间的相似度
c)选出与当前用户最相似的N个用户
d)将这N个用户评价最高并且当前用户又没有浏览过的item推荐给当前用户。

2.基于物品的协同过滤推荐
基于项目的协同过滤推荐的基本原理也是类似的，只是说它使用所有用户对物品或者信息的偏好，发现物品和物品之间的相似度，
然后根据用户的历史偏好信息，将类似的物品推荐给用户。

a)分析各个用户对item的浏览记录
b)依据浏览记录分析得出所有item之间的相似度
c)对于当前用户评价高的item，找出与之相似度最高的N个item
d)将这N个item推荐给用户

3.基于模型的协同过滤推荐
基于模型的协同过滤推荐就是基于样本的用户喜好信息，训练一个推荐模型，然后根据实时的用户喜好的信息进行预测，计算推荐。

协同过滤小结
优点:
a. 它不需要严格建模，而且不要求物品的描述是机器可理解的，所以这种方法也是领域无关的。
b. 这种方法计算出来的推荐是开放的，可以共用他人的经验，很好的支持用户发现潜在的兴趣偏好
缺点:
a. 方法的核心是基于历史数据，所以对新物品和新用户都有“冷启动”的问题。
b. 推荐的效果依赖于用户历史偏好数据的多少和准确性。
c. 在大部分的实现中，用户历史偏好是用稀疏矩阵进行存储的，而稀疏矩阵上的计算有些明显的问题，包括可能少部分人的错误偏好会对推荐的准确度有很大的影响等等。
d. 对于一些特殊品味的用户不能给予很好的推荐。
e. 由于以历史数据为基础，抓取和建模用户的偏好后，很难修改或者根据用户的使用演变，从而导致这个方法不够灵活。

"""

"""
2019／09／04 
one-hot encoding
word -> vector 可以计算distance similarity
'喜欢' '稀饭'
'宾馆' 和 '酒店' 两个映射向量应该非常接近

窗口长度7 学习每首歌和前面后面各3首歌曲的关联性
训练方式 每个序列以sentence带入


word2vec 捕捉关联的信息
品类list 送到word2vec里面去学习 ->搭配推荐

歌手与歌手
电脑与键盘 的商品品类list 
[上衣，上衣，牛仔裤，牛仔裤，连衣裙，...] ...牛仔裤周边有上衣 两者关联

LFM : 隐喻义模型 user对item打分 有内部依据 和k个factor有关系
每一个user 会有一个用户向量k维 embedding[user_u]
每一个item 会有一个item的向量k维 embedding[item_v]
k个隐含的维度做关联

LFM实现方式 ：SVD,SVD++,NMF,...





"""
